<?xml version="1.0" encoding="UTF-8"?> 
<fps version="1.1" url="http://code.google.com/p/freeproblemset/">
	<generator name="HUSTOJ" url="http://code.google.com/p/hustoj/"/>
	<item>
<title><![CDATA[Cowculations]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 1:  Cowculations   

A primitive cow culture was discovered by noted anthropologist Dr. Bo
Vine.  Hundreds of computation tablets were unearthed in a pasture
somewhere near Dallas.  Dr. Vine managed to decipher the mystery of the
tablets when he realized they represented mathematical calculations.  He
says &quot;I've always suspected that cows are smarter than they lead us to
believe and here's the proof.  The big breakthrough was realizing that they
are not able to do math by cownting on their fingers, but they are able to
think on their feet.  But now I have hundreds of these tablets and I need
help in verifying my hypothesis.&quot;  

Problem Statement:   Write a program that helps Dr. Vine verify his
hypothesis.  This problem statement describes how he thinks the tablets
should be interpreted.  Each tablet contains six lines and each line contains
a sequence of cow symbols.  The first two lines represent cow numbers,
the next three represent operations on those numbers and the sixth
represents the result. Cow numbers make use of four symbols: V U C and
D most closely represent the marks made by the cow hooves, so we will
use them to represent the symbols.  The numbers on the first two lines of a
tablet are always a sequence of 5 of these symbols, and the number on the
sixth line of a tablet is always a sequence of 8 of these symbols. 

To interpret the cow calculations one must keep track of two numbers,
hereafter referred to as Num1 and Num2.  Originally Num1 is equal to the
number on line 1 of a tablet and Num2 is equal to the number on line 2 of
a tablet.  However the value of Num2 can change as a result of the
operations.  There are four possible operations, represented by the symbols
A, R, L, and N.  

Operation  A' causes Num2 to become the &quot;sum&quot; of Num1 and Num2,
using this addition table:

 A  | V    U    C    D
------------------------
 V  | V    U    C    D
 U  | U    C    D    V,U
 C  | C    D    V,U  U,U
 D  | D    V,U  U,U  C,U


The first symbol in a result box represents the result of the addition.  The
second symbol in a box represents a carry symbol.  

For example U  A' V = U and C  A' C = V with a carry of U. 

Examples of cow addition are:  

VUCDV   A'  VUCDV  =  VDUCV  and   DVVCU   A'  CVUCU  = UUVCVC.

Operation R causes Num2 to have its symbols shifted right one position,
with the rightmost symbol being lost and a  V' being placed into the
leftmost position.  For example VVCDU
would become VVVCD.  Operation L causes Num2 to have its symbols
shifted left one position, with the leftmost symbol being kept and a  V'
placed into the rightmost position.  For example VVCDU would become
VVCDUV.  N is the null operation.  It has no effect on Num2.
After the operations have been performed on Num1 and Num2 the final
value of Num2 is hopefully the value marked on the sixth line of the
tablet.  If the final value of Num2 does not make use of 8 symbols then it
is padded with V's on the left (VDCCC becomes VVVVDCCC).

Dr. Vine says &quot;I have already verified that all the tablets conform to the
hypothesis in terms of the format of the tablets, number of lines and
symbols, types of symbols, etc.  But I need to verify that the result of the
mathematical operation described on lines 1 through 5 is indeed on line 6.&quot;

Input: The first line contains an integer N between 1 and 10 describing
how many tablets are represented. The next 6 * N lines represent the N
tablets as described in the problem statement.

Output: There should be N+2 lines of output. The first line of output
should read COWCULATIONS OUTPUT. There will then be one line of
output for each tablet that states either &quot;Yes&quot; (the tablet follows Dr. Vine's
hypothesis) or &quot;No&quot; (the tablet does not follow Dr. Vine's hypothesis).
The final line of output should read &quot;END OF OUTPUT&quot;.

Example:   The following input
data:

5
VVVVU
VVVVU
A
A
A
VVVVVVUV
VVCCV
VVDCC
L
R
A
VVVVUCVC
VVCCV
VVDCC
R
L
A
VVVVUCVV
VVUUU
VVVVU
A
N
N
VVVVVUCU
DDDDD
VVVVU
A
L
L
UVVVVVVV


should produce the following output:

COWCULATIONS OUTPUT
YES
YES
YES
NO
YES
END OF OUTPUT
</pre>
<div></div>
</meta>
</p>
]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[8
VVCCV
VVDCC
R
L
A
VVVVUCVV
VVUUU
VVVVU
A
N
N
VVVVVUCU
VVVVU
VVVVU
A
A
A
VVVVVVUV
VVCCV
VVDCC
L
R
A
VVVVUCVC
DDDDD
VVVVU
A
L
L
UVVVVVVV
VVVVV
VVVVV
A
R
L
VVVVVVVV
CCDDC
VVUUC
A
A
R
VVVVVVDD
VVVVV
CCCCC
A
N
N
VVVCCCCC]]></test_input>
<test_output><![CDATA[COWCULATIONS OUTPUT
YES
NO
YES
YES
YES
YES
NO
YES
END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[1996 ACM Mid-Atlantic]]></source>
<solution language="Java"><![CDATA[// by Dan Joyce
// solves Problem 1: Cowculations 
// of 1996 Mid Atlantic programming contest

// input is descriptions of cow tablets 
// output tells if the tablets uphold the theory 

// Note:  Cow math is just base 4 math with V=0, U=1, C=2, D=3

import java.io.*;
import java.util.StringTokenizer;
class doinput {


  static String s = " ";                
  static DataInputStream stdin = new DataInputStream(System.in);
  static StringTokenizer s_tok = new StringTokenizer(s);

  public static int nextint() throws java.io.IOException {  
  /* Will return the next integer from the Input Stream.
     Assumes that at least one more integer
     remains in the input stream
  */
  int n;                               

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  n = Integer.parseInt (s_tok.nextToken());
  return n;
  };

  public static String nextsubstring() throws java.io.IOException{
  /* Will return the next substring from the Input Stream.
     Assumes that at least one more substring 
     remains in the input stream
  */
  String Str;

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  Str = s_tok.nextToken();
  return Str;
  };

}

class Main {

  static int convert(String s, int len) {
  /* takes a 'len' character cow string 's' and changes it to
     an integer, based on fact that cow strings are base 4
  */
  int value = 0;
  for (int i = 0; i < len; i++) {
    switch (s.charAt(i)) {
      case 'V': value = (value * 4) + 0;  break;
      case 'U': value = (value * 4) + 1;  break;
      case 'C': value = (value * 4) + 2;  break;
      case 'D': value = (value * 4) + 3;  break;
      }
    }
  return value;
  }

  public static void main (String [] args) throws IOException {

    String in_String;       // input string
    int N;                  // number of tablets
    int Num1, Num2, Num3;

    doinput myinput = new doinput();

    System.out.println ("COWCULATIONS OUTPUT");	

    N = myinput.nextint();

    for (int count = 1; count <= N; count++)
      {
      in_String = myinput.nextsubstring();
      Num1 = convert(in_String,5);
      in_String = myinput.nextsubstring();
      Num2 = convert(in_String,5);
 
      for (int cnt = 1; cnt <=3; cnt++) {
        in_String = myinput.nextsubstring();
        
        if (in_String.equals("A")) {
          Num2 = Num1 + Num2;
          }

        if (in_String.equals("R")) {
          Num2 = Num2 / 4;
          }

        if (in_String.equals("L")) {
          Num2 = Num2 * 4;
          }

        if (in_String.equals("N")) {
          // do nothing
          }
        };

      in_String = myinput.nextsubstring();
      Num3 = convert(in_String,8);

      if (Num2 == Num3) System.out.println("YES");
      else System.out.println("NO"); 

      };

  System.out.println("END OF OUTPUT");
  }
}
]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Intersecting Lines]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 2: Intersecting Lines

We all know that a pair of distinct points on a plane defines a line
and that a pair of lines on a plane will intersect in one of three
ways: 1) no intersection because they are parallel, 2) intersect in a
line because they are on top of one another (i.e. they are the same
line), 3) intersect in a point.  In this problem you will use your
algebraic knowledge to create a program that determines how and
where two lines intersect.

Problem Statement: Your program will repeatedly read in four
points that define two lines in the x-y plane and determine how and
where the lines intersect.  All numbers required by this problem
will be reasonable, say between -1000 and 1000. 

Input:   The first line contains an integer N between 1 and 10
describing how many pairs of lines  are represented.  The next N
lines will each contain eight integers.  These integers represent the
coordinates of four points on the plane in the order x1 y1 x2 y2 x3
y3 x4 y4.  Thus each of these input lines represents two lines on
the plane: the line through (x1,y1) and (x2,y2) and the line through
(x3,y3) and (x4,y4).  The point (x1,y1) is always distinct from
(x2,y2).  Likewise with (x3,y3) and (x4,y4).

Output: There should be N+2 lines of output.  The first line of
output should read INTERSECTING LINES OUTPUT.  There will
then be one line of output for each pair of planar lines represented
by a line of input, describing how the lines intersect: none, line, or
point.  If the intersection is a point then your program should
output the x and y coordinates of the point, correct to two decimal
places.  The final line of output should read &quot;END OF OUTPUT&quot;.

Example:   The following input data:

5
0 0 4 4 0 4 4 0
5 0 7 6 1 0 2 3
5 0 7 6 3 -6 4 -3
2 0 2 27 1 5 18 5
0 3 4 0 1 2 2 5

should produce the following output:

INTERSECTING LINES OUTPUT
POINT 2.00 2.00
NONE
LINE
POINT 2.00 5.00
POINT 1.07 2.20
END OF OUTPUT</pre>
</meta>
</p>
]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[7
-7 2 -7 8 2 3 2 7
-2 3 13 3 -2 -5 13 -5
0 0 3 5 6 10 -3 -5
-3 10 -3 -15 -3 5 2 5
5 1 15 5 8 5 4 11
3 6 3 3 3 -3 3 -5
3 6 3 3 2 7 2 8]]></test_input>
<test_output><![CDATA[INTERSECTING LINES OUTPUT
NONE
NONE
LINE
POINT -3.00 5.00
POINT 9.47 2.79
LINE
NONE
END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="C++"><![CDATA[#include<iostream>
#include<stdio.h>
using namespace std;
const double epx=1e-10;
struct Point
{
    double x;
    double y;
};
//求解二元一次方程
Point solve(double a1,double b1,double c1,double a2,double b2,double c2)
{
    Point p;
    p.x=(c1*b2-c2*b1)/(a2*b1-a1*b2);
    p.y=(a2*c1-a1*c2)/(a1*b2-a2*b1);
    return p;
}
//p1p3,p1p2的叉积
double direction(Point p1,Point p2,Point p3)
{
    return (p3.x-p1.x)*(p2.y-p1.y)-(p2.x-p1.x)*(p3.y-p1.y);
}
//判断两直线的关系
/*
在这里有三种关系：1共线 2平行 3相交
1 共线可通过叉积来判断
2 平行通过向量来判断
3 通了上面2种情况的其他情况
  求交点可通过叉积及解二元一次方程来求解
*/
int N;
Point p1,p2,p3,p4;
Point p0;//交点
double a1,b1,c1,a2,b2,c2;
int main()
{
    scanf("%d",&N);
    int i;
    printf("INTERSECTING LINES OUTPUT\n");
    for(i=0;i<N;++i)
    {
        scanf("%lf%lf%lf%lf%lf%lf%lf%lf", &p1.x, &p1.y, &p2.x, &p2.y, &p3.x, &p3.y, &p4.x, &p4.y);
        
        if(direction(p3,p4,p1)==0 && direction(p3,p4,p2)==0)//共线
            printf("LINE\n");
        else
        {
            if( ((p1.x-p2.x)*(p3.y-p4.y)-(p1.y-p2.y)*(p3.x-p4.x))==0 )//平行
                printf("NONE\n");
            else
            {
                a1=p1.y-p2.y;b1=p2.x-p1.x;c1=p1.x*p2.y-p2.x*p1.y;
                a2=p3.y-p4.y;b2=p4.x-p3.x;c2=p3.x*p4.y-p4.x*p3.y;
                p0=solve(a1,b1,c1,a2,b2,c2);
                printf("POINT %.2f %.2f\n",p0.x,p0.y);
            }
        }
    }
    printf("END OF OUTPUT\n");
    return 0;
}]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Hi-Q]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 3: Hi-Q

Hi-Q is a popular solitaire game that comes in a small box with a
playing board that has little holes in the shape of a cross and 32
little pegs that fit into the holes.  Starting with the centermost hole
open, players move the pegs by jumping one peg over another,
either in a horizontal or vertical direction and removing each peg
that is jumped over.  Diagonal jumps are not allowed.  The object
for players is to remove as many pegs from the board as possible. 
This problem involves writing a program that will automatically
play Hi-Q so that we can investigate how the game might unfold
based on various opening arrangements of pegs.

Problem Statement: There is a peg board with the following
shape and with holes numbered from 1 to 33 as follows:

                          1         2         3
                          4         5         6
      7         8         9        10        11        12        13
     14        15        16        17        18        19        20
     21        22        23        24        25        26        27        
                         28        29        30
                         31        32        33

An instance of the game begins with some holes having pegs in
them and the rest of the holes being empty.   The game proceeds by
jumping one peg over another, either horizontally or vertically,
with the peg that is jumping landing in an empty hole, and the peg
being jumped over being removed from the board.  For example, if
9 is empty and 10 and 11 are not, then the peg in 11 can be
&quot;moved&quot; to 9 with the peg in 10 being removed. After this move,
10 and 11 would both be empty but 9 would have a peg in it.

Given a specific board configuration your program will pick and
model a specific move, over and over, until no more moves are
available. Your program will then report the sum of the holes that
still have pegs in them.  At any point during the game there may be
more than one possible move available.  In such a case always
model the move with the target hole of the moving peg as large as
possible.  If there is more than one move available to the largest
possible target hole, then choose from those moves the one with
the larger source hole.

For example, if the board looks like this, with X representing a peg
and O representing a hole:

                              O         O         O
                              O         O         O
          O         O         O         X         O         X         O
          O         O         O         X         O         X         O
          O         O         O         O         X         O         O
                              O         O         O
                              O         O         O

then the following jumps would be made: 1: from 12 over 19 to 26
(26, 24, and 5 are the only possible targets and 26 is the largest), 2:
from 26 to 24 over 25 (5 and 24 are the only possible targets with
24 &gt; 5 plus 24 is the target for two possible moves, one from 26
and one from 10; the one from 26 is used since 26 &gt; 10), 3: from
17 to 29 (29 &gt; 5), and two pegs would be left, one in hole 10 and
one in hole 29.  Thus 39 would be reported as the result for this
instance.

[NOTE: The above paragraph is wrong.  This was discovered shortly
 after the contest began, and the correction was broadcast to all
 teams. The second jump should be from 25 to 27. The third jump
 should be from 10 to 24. The two pegs left will be in holes 24
 and 27 and 51 should be reported as the result.]

Input:   The first line contains an integer N between 1 and 10
describing how many instances of the game are represented.  The
remaining lines will describe N instances of the game by listing the
holes which begin with pegs in them, in increasing order.  A 0 will
indicate the end of each  sequence of unique numbers between 1
and 33 that represents an instance of the game.

Output: There should be N+2 lines of output.  The first line of
output will read HI Q OUTPUT. There will then be one line of
output for each instance of the game, reporting the sum of the holes
that still have pegs in them for the final configuration of that
instance.. The final line of output should read END OF OUTPUT .

Example:   The following input data:

4
10 12 17 19 25 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
16 17 18 19 20
21 22 23 24 25 26   27 28 29 30 31 32 33 0
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 18 19 20
21 22 23 24 25 26 27 28 29 30 31 32 33 0

should produce the following output:

HI Q OUTPUT
51                                                          
0
561  
98
END OF OUTPUT
</pre>
<div></div>
</meta>
</p>
]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[7
1 2 10 12 17 19 25 0 1 2 3 7 9 11 13
14 16 18 20 21 23 25 27 31 32 33 0
0 24 29 0 9 10 0 1 2 6 12 17 20 22
26 28 30 32 0 1 4 7 8 26 27 30 33 0]]></test_input>
<test_output><![CDATA[HI Q OUTPUT
54
214
0
32
11
29
68
END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="Java"><![CDATA[// by Dan Joyce
// solves Problem 2: Intersecting Lines
// of 1996 Mid Atlantic Programming Contest

// input is a list of pairs of coordinates that define pairs of lines 
// output ids each pair of lines as intersecting, parallel, or equal 

import java.io.*;

import java.util.StringTokenizer;

/********************************************************************/

class doinput {


  static String s = " ";                
  static DataInputStream stdin = new DataInputStream(System.in);
  static StringTokenizer s_tok = new StringTokenizer(s);

  public static int nextint() throws java.io.IOException {  
  /* Will return the next integer from the Input Stream.
     Assumes that at least one more integer
     remains in the input stream
  */
  int n;                               

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  n = Integer.parseInt (s_tok.nextToken());
  return n;
  };

  public static String nextsubstring() throws java.io.IOException{
  /* Will return the next substring from the Input Stream.
     Assumes that at least one more substring 
     remains in the input stream
  */
  String Str;

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  Str = s_tok.nextToken();
  return Str;
  };

}

class Main {

  static int first(int n)   {
  // returns first coordinate of the board location N
  if ((n > 0) && (n <4)) return 2;
  if ((n > 3) && (n <7)) return 3;
  if ((n > 6) && (n <14)) return 4;
  if ((n > 13) && (n <21)) return 5;
  if ((n > 20) && (n <28)) return 6;
  if ((n > 27) && (n <31)) return 7;
  if ((n > 30) && (n <34)) return 8;
  return 0;
  };

  static int second(int n)  {
  // returns second coordinate of the board location N
  switch (n) {
    case  1: return  4;   
    case  2: return  5; 
    case  3: return  6;  
    case  4: return  4;  
    case  5: return  5;  
    case  6: return  6;  
    case  7: return  2;  
    case  8: return  3;
    case  9: return  4;   
    case 10: return  5;   
    case 11: return  6;   
    case 12: return  7;   
    case 13: return  8;   
    case 14: return  2;   
    case 15: return  3;   
    case 16: return  4;   
    case 17: return  5;   
    case 18: return  6;   
    case 19: return  7;   
    case 20: return  8;   
    case 21: return  2;   
    case 22: return  3;   
    case 23: return  4;   
    case 24: return  5;   
    case 25: return  6;   
    case 26: return  7;   
    case 27: return  8;   
    case 28: return  4;   
    case 29: return  5;   
    case 30: return  6;   
    case 31: return  4;   
    case 32: return  5;   
    case 33: return  6;   
    };
  return 0;
  };

  public static void main (String [] args) throws IOException {

    int count;                           // number of puzzles
    int puzzle [][] = new int [11][11];  // holds one puzzle
                                         // 0 = unavailable, 1 = hole, 2 = peg
    int pos, testpos;                    // puzzle position 1 .. 33
    int first, second;                   // puzzle coordinates
    boolean mademove;
    int sum;

    doinput myinput = new doinput();

    System.out.println ("HI Q OUTPUT");

    count = myinput.nextint();

    for (int i = 1; i <= count; i++) 
      {
      // initialize board
      for (int j = 0; j <= 10; j++)    // first set all to holes
        for (int k = 0; k <= 10; k++)
          puzzle[j][k] = 1;
      for (int j = 0; j <= 10; j++)    // next make border unavailable
        {puzzle[0][j] = 0;
         puzzle[1][j] = 0;
         puzzle[9][j] = 0;
         puzzle[10][j] = 0;
         puzzle[j][0] = 0;
         puzzle[j][1] = 0;
         puzzle[j][9] = 0;
         puzzle[j][10] = 0;
        };
      for (int j = 2; j <= 3; j++)    // do rest of the unavailable
        {puzzle[j][2] = 0;
         puzzle[j][3] = 0;
         puzzle[j][7] = 0;
         puzzle[j][8] = 0;
        };
      for (int j = 7; j <= 8; j++)
        {puzzle[j][2] = 0;
         puzzle[j][3] = 0;
         puzzle[j][7] = 0;
         puzzle[j][8] = 0;
        };
      pos = myinput.nextint();       // read and assign pegs to holes
      while (pos != 0)
        {first = first(pos);
         second = second(pos);
         puzzle[first][second] = 2;
         pos = myinput.nextint();
        };

      // solve puzzle
      mademove = true;
      while (mademove) 
        {mademove = false;
         testpos = 33;
         while ((testpos != 0) && !mademove)
           {first = first(testpos);
            second = second(testpos);
            if (puzzle[first][second] == 1)
              {if ((puzzle[first+1][second] ==  2) 
                    && (puzzle[first+2][second] == 2))
                   {puzzle[first+1][second] = 1;
                    puzzle[first+2][second] = 1;
                    puzzle[first][second] = 2;
                    mademove = true;}
               else
               if ((puzzle[first][second+1] ==  2) 
                    && (puzzle[first][second+2] == 2))
                   {puzzle[first][second+1] = 1;
                    puzzle[first][second+2] = 1;
                    puzzle[first][second] = 2;
                    mademove = true;}
               else              
               if ((puzzle[first][second-1] ==  2) 
                    && (puzzle[first][second-2] == 2))
                   {puzzle[first][second-1] = 1;
                    puzzle[first][second-2] = 1;
                    puzzle[first][second] = 2;
                    mademove = true;}
               else              
               if ((puzzle[first-1][second] ==  2) 
                    && (puzzle[first-2][second] == 2))
                   {puzzle[first-1][second] = 1;
                    puzzle[first-2][second] = 1;
                    puzzle[first][second] = 2;
                    mademove = true;}
              };
            testpos = testpos - 1;
            };  // while  testpos != 0 ...
         }; // while mademove

      // get and print final count
      sum = 0;
      for (int j = 33; j > 0; j = j -1)
        {first = first(j);
         second = second(j);
         if (puzzle[first][second] == 2)
            sum = sum + j;
        };
      System.out.println(sum);

      }; // end for count

    System.out.println ("END OF OUTPUT");
   }
}
]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Call Forwarding]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 4: Call Forwarding

Thanks to computer technology the functionality of phone systems
has been greatly enhanced in the last ten years.  We have
automated menus, sophisticated answering machines, conference
call capabilities, group addressing and so on.  A common feature of
a company's phone system is the ability to set call forwarding. For
example, if Bob at the Nobody's Home Company (NHC) goes on
vacation, he sets things up so that all calls coming to him are
forwarded to his associate Jane.  This problem addresses how
phone systems might keep track of call forwarding.

Problem Statement: The phones at the NHC all have four digit
extensions.  Employees can set call forwarding by entering the
appropriate information through their telephone interface.  If an
employee is going to be away they enter the following information:
their extension, the time they are leaving, how long they will be
away, and the extension that their calls should be forwarded to,
with the following constraints:

  -  All extensions consist of four digits.
  -  The extensions 0000 and 9999 are reserved for special use and
     will not be entered as information by an employee.
  -  Times are recorded in increments of 1 hour and are based on a
     clock that begins at 0000 at midnight every New Year's Eve. 
     Therefore, when describing the time they are leaving,
     employees always use an integer between 0000 and 8784
     (which is 366*24).  The call forwarding system is completely
     reset at the beginning of the year.
  -  A call forward set to start at time X for a duration of Y will be
     in effect from time X to time X+Y inclusive.

Users are &quot;good&quot; about the requests they enter.  They follow the
format rules. They do not enter a request such that the duration of
the request would go past the end of the year. They do not enter
two requests for their extension that overlap in time.  Even though
the users enter correct, clear, non-overlapping information from
their own point of view, a degenerate situation can still occur in a
call forwarding system, if requests have been made in such a way
as to forward a call back to the original target of the call.  For
example if Bob forwards his calls to Sue, and Sue forwards her
calls to Joe, and Joe forwards his calls to Bob then when somebody
calls any of these three people their calls would be forwarded
forever.  To prevent this situation the call forwarding system uses
the &quot;dead end&quot; number 9999.  Any calls made to an extension
involved in such a degenerate situation will be forwarded to the
special 9999 extension.

Input:   The first line contains an integer N between 1 and 10
describing how many call forwarding systems will be simulated by
your program.  Each call forwarding system will be represented by
0 to 100  source time duration target' lines.  These lines represent
the requests by the users to set up a call forwarding from the
source' to the  target' starting at the  time' for a length of
duration', and will be in the form  dddd dddd dddd dddd'. A line
with 0000 in the  source' position indicates the end of this portion
of the input. The call forwarding requests are listed in the order
received. They will be followed by 1 or more  time extension'
lines, in the form  dddd dddd', in non-decreasing order by  time'
representing calls made into the system at  time' to  extension'. A
line with 9000 in the  time' position indicates the end of this
portion of the input.

Output: The first line of output must read CALL FORWARDING
OUTPUT.  This will be followed by sections of information about
each of the call forwarding systems being simulated.  Each of these
sections should be headed by the line SYSTEM N, where N is the
number (1, 2, ...) of the system.  Within the section there should be
a line describing the result of each of the calls made into the
system, with the format &quot;AT dddd CALL TO dddd RINGS dddd&quot;. 
The final line of output should read END OF OUTPUT .

Example:   The following input data:

2
1111 0100 0200 2222
1111 0301 0500 4444
2222 0200 0200 3333
3333 0250 1000 1111
7777 1000 2000 7777
0000
0050 1111
0150 1111
0200 1111
0225 2222
0270 1111
0320 1111
0320 3333
0900 3000
1250 3333
1250 7777
9000
0000
3000 1111
9000

should produce the following output:

CALL FORWARDING OUTPUT
SYSTEM 1
AT 0050 CALL TO 1111 RINGS 1111
AT 0150 CALL TO 1111 RINGS 2222
AT 0200 CALL TO 1111 RINGS 3333
AT 0225 CALL TO 2222 RINGS 3333
AT 0270 CALL TO 1111 RINGS 9999
AT 0320 CALL TO 1111 RINGS 4444
AT 0320 CALL TO 3333 RINGS 4444
AT 0900 CALL TO 3000 RINGS 3000
AT 1250 CALL TO 3333 RINGS 1111
AT 1250 CALL TO 7777 RINGS 9999
SYSTEM 2
AT 3000 CALL TO 1111 RINGS 1111
END OF OUTPUT
</pre>
<div></div>
</meta>
</p>
]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[3
1111 0100 0200 2222
1111 0301 0500 4444
2222 0200 0200 3333
3333 0250 1000 1111
7777 1000 2000 7777
0000
0050 1111
0150 1111
0200 1111
0225 2222
0270 1111
0320 1111
0320 3333
0900 3000
1250 3333
1250 7777
9000
0001 0100 0300 0002
0002 0100 0300 0003
0003 0100 0300 0004
0004 0100 0300 0005
0005 0100 0200 0006
0006 0100 0200 0007
0007 0200 0200 0001
0000
0150 0001
0150 0005
0150 0007
0250 0001
0250 0005
0250 0007
0350 0001
0350 0005
0350 0007
9000
0001 0100 0300 0002
0000
0050 0001
0100 0001
0150 0001
0200 0002
0400 0001
0401 0001
9000
]]></test_input>
<test_output><![CDATA[CALL FORWARDING OUTPUT
SYSTEM 1
AT 0050 CALL TO 1111 RINGS 1111
AT 0150 CALL TO 1111 RINGS 2222
AT 0200 CALL TO 1111 RINGS 3333
AT 0225 CALL TO 2222 RINGS 3333
AT 0270 CALL TO 1111 RINGS 9999
AT 0320 CALL TO 1111 RINGS 4444
AT 0320 CALL TO 3333 RINGS 4444
AT 0900 CALL TO 3000 RINGS 3000
AT 1250 CALL TO 3333 RINGS 1111
AT 1250 CALL TO 7777 RINGS 9999
SYSTEM 2
AT 0150 CALL TO 0001 RINGS 0007
AT 0150 CALL TO 0005 RINGS 0007
AT 0150 CALL TO 0007 RINGS 0007
AT 0250 CALL TO 0001 RINGS 9999
AT 0250 CALL TO 0005 RINGS 9999
AT 0250 CALL TO 0007 RINGS 9999
AT 0350 CALL TO 0001 RINGS 0005
AT 0350 CALL TO 0005 RINGS 0005
AT 0350 CALL TO 0007 RINGS 0005
SYSTEM 3
AT 0050 CALL TO 0001 RINGS 0001
AT 0100 CALL TO 0001 RINGS 0002
AT 0150 CALL TO 0001 RINGS 0002
AT 0200 CALL TO 0002 RINGS 0002
AT 0400 CALL TO 0001 RINGS 0002
AT 0401 CALL TO 0001 RINGS 0001
END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="Java"><![CDATA[// by Dan Joyce
// solves Problem 2: Intersecting Lines
// of 1996 Mid Atlantic Programming Contest

// input is a list of pairs of coordinates that define pairs of lines 
// output ids each pair of lines as intersecting, parallel, or equal 

import java.io.*;

import java.util.StringTokenizer;

/********************************************************************/

class doinput {


  static String s = " ";                
  static DataInputStream stdin = new DataInputStream(System.in);
  static StringTokenizer s_tok = new StringTokenizer(s);

  public static int nextint() throws java.io.IOException {  
  /* Will return the next integer from the Input Stream.
     Assumes that at least one more integer
     remains in the input stream
  */
  int n;                               

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  n = Integer.parseInt (s_tok.nextToken());
  return n;
  };

  public static String nextsubstring() throws java.io.IOException{
  /* Will return the next substring from the Input Stream.
     Assumes that at least one more substring 
     remains in the input stream
  */
  String Str;

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  Str = s_tok.nextToken();
  return Str;
  };

}

class Main {

  public static void main (String [] args) throws IOException {

    String forward [][] = new String [101][4];  // forwarding data
                                                // source time duration target
    int N;                // number of systems 
    String willring;      // the extension that will ring
    boolean madechange;   // true if another forward found    
    int fcount;           // how many forwardings found this time
    int i;                // used to index forward array
    int fsize;            // size of valid part of forward array
    String source, extension, time;
    int curtime, testtime, testdur;

    doinput myinput = new doinput();

    System.out.println ("CALL FORWARDING OUTPUT");

    N = myinput.nextint();

    for (int count = 1; count <= N; count++)
      {
      System.out.println("SYSTEM " + count);
      source = myinput.nextsubstring();
      i = 0;
      while (!source.equals("0000")) {
        i = i + 1;                      // not using forward[0]
        forward[i][0] = source;
        forward[i][1] = myinput.nextsubstring();
        forward[i][2] = myinput.nextsubstring();
        forward[i][3] = myinput.nextsubstring();
        source = myinput.nextsubstring();
        };
      fsize = i;
      time = myinput.nextsubstring();
      while (!time.equals("9000")) {
         extension = myinput.nextsubstring();
         willring = extension;
         // an easy, inelegant way to discover degenerate situations
         // ie loops in the forwarding chain is to just count how
         // many forwarding were discovered ... if this goes over
         // 100 then stop searching and forward to 9999 ... thus
         // I use fcount to count the number of forwardings found
         fcount = 0;
         madechange = true;   // continue trying if a forward was found
         while ((fcount <= 102) && madechange) {
            madechange = false;
            for (i = 1; i <= fsize; i++) {
               curtime = Integer.parseInt(time);
               testtime = Integer.parseInt(forward[i][1]);
               testdur = Integer.parseInt(forward[i][2]);
               if ((willring.equals(forward[i][0]))
                   &&
                   (curtime >= testtime)
                   &&
                   (curtime <= ( testtime + testdur)))
                   {fcount = fcount + 1;
                    madechange = true;
                    willring = forward[i][3];
                   };
                };
             };
         if (fcount >= 101) willring = "9999";
         System.out.print("AT " + time + " CALL TO " + extension);
         System.out.println(" RINGS " + willring);
         time = myinput.nextsubstring();
         };
      }; 

    System.out.println ("END OF OUTPUT");
  }
}
]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Making the Grade]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 5: Making the Grade

Mr. Chips has a simple grading scheme that lends itself to
automated computation.  You will write a program that will read in
his students' grades, bonus points, and attendance record, compute
the student's grades, and output the average grade point of the
class.

Problem Statement: Mr. Chips grades as follows.  All tests are
based on 100 points and all test grades are between 0 and 100
points. If he has given more than 2 tests then he will drop the
lowest test grade for each student before computing student
averages.  After computing student averages he computes the
overall class average (mean) and standard deviation (sd). The
cutoff points for grades are: an average &gt;= one sd above the mean is
an A, an average &gt;= the mean but &lt; one sd above the mean is a B,
an average &gt;= one sd below the mean but &lt; the mean is a C, and an
average &lt; one sd below the mean is a D.  For every two bonus
points accrued by a student Mr. Chips increases their computed
average by 3 percentage points. Thus, if students have one bonus
point, their averages are not bumped at all.  If they have 4 or 5
bonus points, their averages are bumped by 6 percentage points,
and so on. Bumping of averages based on bonus points takes place
after the grade cutoff points have been determined.  Finally, for
every 4 absences, students lose one letter grade (from A to B, B to
C, C to D, and D to F).  For example, if they have 9 absences they
will lose two letter grades. Students cannot get a grade lower than
F. If students have perfect attendance, they gain one letter grade;
although they cannot get a grade higher than an A.  During his
computations, Mr. Chips always rounds his results to the nearest
tenth. In summary, Mr. Chips drops a student's lowest test grade if
more than 2 tests have been administered, computes each student's
average, computes the class mean and sd, adjusts the students'
averages based on bonus points, determines the student's
unadjusted grades, and then adjusts the grades based on attendance.

The average grade point of a class is determined by using 4 points
for each A, 3 points for each B, 2 points for each C, 1 point for
each D, and 0 points for each F.  The total points for the class are
added together and divided by the number of students in the class
(which is always at least 2).

The standard deviation sd of a list of numbers x1, ..., xn
is:    [graphic deleted]

If the calculated standard deviation is less than 1 then Mr. Chips
uses 1 in place of the standard deviation for grade calculation.

Suppose Mr. Chips has 5 students and has given 3 tests. The
following table shows the grades, number of bonuses and days
absent, plus the computed average (with lowest test dropped), the
adjusted average (with bonus), the unadjusted grade and the
adjusted grade (with attendance). The mean and sd used to
determine letter grade cutoffs are 69.0 and 20.1. For example, for
an unadjusted B, one's average must be greater than or equal to
69.0 and less than 89.1.

 T1   T2  T3 Bns Abst  Avg     AdjAvg   Grade  AdjGrd
100  100  80 3    2   100.0    103.0     A       A
 80   80  80 0    5    80.0     80.0     B       C
 60   20  70 5    3    65.0     71.0     B       B
 40   40  40 5    0    40.0     46.0     D       C
100   20  20 1    9    60.0     60.0     C       F         

avg grd pnt is 2.2

Input:   The first line contains an integer N between 1 and 10
describing how many of Mr. Chip's classes are represented in the
input.  The first line for each class contains two integers S and T. S
is the number of students in the class (1 &lt; S &lt; 31) and T is the
number of tests the students took (1 &lt; T &lt; 11).  The next S lines
will each represent one student in the class. A student line first lists
each of their T test scores as integers between 0 and 100 inclusive,
and then lists their bonus points and their number of absences.

Output: There should be N+2 lines of output.  The first line of
output should read MAKING THE GRADE OUTPUT.   There will
then be one line of output for each of Mr. Chip's classes showing
that class's average grade point. The final line of output should
read END OF OUTPUT.

Example:   The following input data:

3
3 2
100 50 2 5
60 60 17 1
20 10 0 0
5 5
100  80  90  80  90   0   0
80 80 80 80 80   0 0
50 50 50 50 50 0 0
100 100 20 20 20 0 0
30 30 30 30 30 0 0
10  4
79   56   59   89    4    5
100   89   96   79    6    2
80   80   80   76    1    3
76   76   76   76    5    4
58   78   67   75    4    0
100   96  100   95    1    2
47   49   46   45    0    5
67   98   59   87    5    5
23   45   52   54    2    7
78   75   79   79    3    3

should produce the following output:

MAKING THE GRADE OUTPUT
3.0
3.2
2.4
END OF OUTPUT</pre>
</meta>
</p>
]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[3
10  4
79   56   59   89    4    5
100   89   96   79    6    2
80   80   80   76    1    3
76   76   76   76    5    4
58   78   67   75    4    0
100   96  100   95    1    2
47   49   46   45    0    5
67   98   59   87    5    5
23   45   52   54    2    7
78   75   79   79    3    3
4  2
100  100   0  1
100  60   0  1
60  60  0  1
80  0  0  1
9  4
55   56   59   89    4    5
100   89   96   54    6    2
80  100   80   76    1    3
76   76   76   76   20    4
58   78   67   75    4    0
100   23   55   95    1    2
67   98   59   87    5   12
20  100  100  100    2    7
100  100  100   86    3    3]]></test_input>
<test_output><![CDATA[MAKING THE GRADE OUTPUT
2.4
2.5
2.4
END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="Java"><![CDATA[// by Dan Joyce
// solves Problem 2: Intersecting Lines
// of 1996 Mid Atlantic Programming Contest

// input is a list of pairs of coordinates that define pairs of lines 
// output ids each pair of lines as intersecting, parallel, or equal 

import java.io.*;

import java.util.StringTokenizer;

/********************************************************************/

class doinput {


  static String s = " ";                
  static DataInputStream stdin = new DataInputStream(System.in);
  static StringTokenizer s_tok = new StringTokenizer(s);

  public static int nextint() throws java.io.IOException {  
  /* Will return the next integer from the Input Stream.
     Assumes that at least one more integer
     remains in the input stream
  */
  int n;                               

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  n = Integer.parseInt (s_tok.nextToken());
  return n;
  };

  public static String nextsubstring() throws java.io.IOException{
  /* Will return the next substring from the Input Stream.
     Assumes that at least one more substring 
     remains in the input stream
  */
  String Str;

  while (s_tok.countTokens() == 0) {
    s = stdin.readLine();       
    s_tok = new StringTokenizer(s);
    };
  Str = s_tok.nextToken();
  return Str;
  };

}

class Main {

  public static void main (String [] args) throws IOException {

    int n, s, t;                         // number of classes, students, tests
    int tgrades [][] = new int [32][12]; // tgrades
    int bonus [] = new int [32];         // bonus points
    int absents [] = new int [32];       // absences
    float averages [] = new float [32];  // averages
    int grades [] = new int [32];        // grades
    int lowest, sum;                     // for average calculation
    float fsum, classavg, classSD;       // float sum, class average and SD
    float avgGradePts;                   // average grade points
    int i, j, k;                         // loop control

    doinput myinput = new doinput();

    System.out.println ("MAKING THE GRADE OUTPUT");

    // get count of classes 
    n = myinput.nextint();

  for (k=1; k <= n; k++)
    {
    // get inout
    s = myinput.nextint();
    t = myinput.nextint();
    for (i = 1; i <= s; i++)
      { for (j = 1; j <= t; j++)
          { 
           tgrades[i][j] = myinput.nextint();
          };
        bonus[i] = myinput.nextint();
        absents[i] = myinput.nextint();
      };

    // calculate averages
    if (t > 2)   // drop lowest grade
      { for (i=1; i <= s; i++)
          { lowest = 100;  sum = 0;
            for (j=1; j <= t; j++)
              { if (tgrades[i][j] < lowest) lowest = tgrades[i][j];
                sum = sum + tgrades[i][j]; 
              };
            averages[i] = ((float)(sum - lowest)) / ((float)(t-1));
          };
      }
    else        // do not drop lowest grade
      { for (i=1; i <= s; i++)
          { sum = 0;
            for (j=1; j <= t; j++)
              sum = sum + tgrades[i][j];
            averages[i] = (float) sum / (float) t;
            averages[i] = (float) ( (float) (Math.round(averages[i] * 10)) 
                          / 10.0 );
          };
      };

    // calculate class average
    fsum = 0;
    for (i=1; i <= s; i++)
      fsum = fsum + averages[i];
    classavg = (fsum / (float) s);
    classavg = (float)( (float) (Math.round(classavg * 10)) / 10.0 );

    // calculate class standard deviation
    fsum = 0;
    for (i=1; i <= s; i++)
      fsum = fsum + ((classavg-averages[i])*(classavg-averages[i]));
    fsum = fsum/s;
    classSD = (float) Math.sqrt(fsum);
    classSD = (float) ( (float) (Math.round(classSD * 10)) / 10.0 );
    if (classSD < 1.0) classSD = (float) 1.0;

    // add bonus points into student averages
    for (i=1; i <= s; i++)
      averages[i] = averages[i] + ((bonus[i] / 2 ) * 3);

    // determine unadjusted grades
    for (i=1; i <= s; i++)
      { if (averages[i] >= (classavg + classSD) ) grades[i] = 4;
        else if (averages[i] >= (classavg) )      grades[i] = 3;
        else if (averages[i] >= (classavg - classSD) ) grades[i] = 2;
        else grades[i] = 1;
      }

    // adjust grades for absences
    for (i=1; i <= s; i++)
      { grades[i] = grades[i] - (absents[i] / 4);
        if (grades[i] < 0) grades[i] = 0;
      };

    // adjust for perfect attendance
    for (i=1; i <= s; i++)
        if ( ( grades[i] != 4 ) && (absents[i] == 0))
           grades[i] = grades[i] + 1;

    // calculate average grade points
    sum = 0;
    for (i=1; i <= s; i++)
       sum = sum + grades[i];
    avgGradePts = (float) sum  / (float) s;
    avgGradePts = (float)( (float) (Math.round(avgGradePts * 10)) / 10.0 );

    System.out.println (avgGradePts); 
    }  // end of the for k loop

    System.out.println ("END OF OUTPUT");
  }
}
]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Perfection]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8"> </meta>
</p>
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 6: Perfection

From the article Number Theory in the 1994 Microsoft Encarta: &quot;If
a, b, c are integers such that a = bc, a is called a multiple of b or of
c, and b or c is called a divisor or factor of a. If c is not �1, b is
called a proper divisor of a. Even integers, which include 0, are
multiples of 2, for example, -4, 0, 2, 10; an odd integer is an
integer that is not even, for example, -5, 1, 3, 9. A perfect number
is a positive integer that is equal to the sum of all its positive,
proper divisors; for example, 6, which equals 1 + 2 + 3, and 28,
which equals 1 + 2 + 4 + 7 + 14, are perfect numbers. A positive
number that is not perfect is imperfect and is deficient or abundant
according to whether the sum of its positive, proper divisors is
smaller or larger than the number itself. Thus, 9, with proper
divisors 1, 3, is deficient; 12, with proper divisors 1, 2, 3, 4, 6, is
abundant.&quot;

Problem Statement:  Given a number, determine if it is perfect,
abundant, or deficient.

Input: A list of N positive integers (none greater than 60,000),
with 1 &lt; N &lt; 100. A 0 will mark the end of the list.

Output: The first line of output should read PERFECTION
OUTPUT.  The next N lines of output should list for each input
integer whether it is perfect, deficient, or abundant, as shown in the
example below.  Format counts: the echoed integers should be
right justified within the first 5 spaces of the output line, followed
by two blank spaces, followed by the description of the integer. 
The final line of output should read END OF OUTPUT .

Example:   The following input data:

15 28 6 56 60000 22 496 0

should produce the following output:

PERFECTION OUTPUT
15  DEFICIENT
28  PERFECT
6  PERFECT
56  ABUNDANT
60000  ABUNDANT
22  DEFICIENT
496  PERFECT
END OF OUTPUT
</pre>
<div></div>

]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[6 28 60 150 8128 53 5 1
50000 28 120 0
]]></test_input>
<test_output><![CDATA[PERFECTION OUTPUT
6  PERFECT
28  PERFECT
60  ABUNDANT
150  ABUNDANT
8128  PERFECT
53  DEFICIENT
5  DEFICIENT
1  DEFICIENT
50000  ABUNDANT
28  PERFECT
120  ABUNDANT
END OF OUTPUT
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="C++"><![CDATA[#include <iostream>
#include <stdio.h>
#define  DEBUG 0
using namespace std ;

int main()
{
 
 cout << "PERFECTION OUTPUT" << endl ;
 int i, n ;
 while( cin >> n, n ){
  if( n == 1 ){
   printf("%5d  DEFICIENT\n", n ) ;
   continue ;
  }
  int up = n/2 ;
  int sum(1) ;
  for( i=2; i<=up; ++i ){
   if( n%i == 0 )
    sum += i ;
  }
  if( sum < n )
   printf("%5d  DEFICIENT\n", n ) ;
  else if( sum == n )
   printf("%5d  PERFECT\n", n ) ;
  else
   printf("%5d  ABUNDANT\n", n ) ;
 }
 cout << "END OF OUTPUT" << endl ;
 return 0 ;
}]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Shipping Routes]]></title>
<time_limit><![CDATA[20]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">  </meta>
</p>
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 7:  Shipping Routes

The Slow Boat to China Shipping company needs a program to
help them quickly quote costs to prospective customers. The cost
of a shipment depends on the size of the shipment and on how
many shipping legs it requires.  A shipping leg connects two
warehouses, but since every pair of warehouses is not directly
connected by a leg, it might require more than one leg to send a
shipment from one warehouse to another.  

Problem Statement:   A data set can represent from 1 to 30
warehouses. A two-letter code name will identify each warehouse
(capital letters only).  Shipping legs can exist between any two
distinct warehouses. All legs are bidirectional. 

The cost of a shipment is equal to the size of the shipment times
the number of shipping legs required times $100.

The input to the program identifies the warehouse code names and
the existence of all shipping legs.  For a given shipping request,
consisting of the size of the shipment, the source warehouse and
the destination warehouse, the program will output the best
(cheapest) cost for the shipment, if it is possible to send shipments
from the requested source to the requested destination. Alternately,
the program must state that the request cannot be fulfilled.  

Input:  The first line will contain an integer from 1 to 10 inclusive
that represents the number of  data sets in the input file.  Each data
set represents a new shipping configuration.

The first line of data in a data set will contain three integers, say
M, N, and P:  M is an integer from 1 to 30 inclusive representing
the number of warehouses in the data set;  N is an integer from 0 to
M*(M-1)/2 inclusive that represents the number of legs between
warehouses in the data set; P is an integer from 0 to 10 inclusive
that represents the number of shipping requests for which cost
information is required.  

The second line of data in a data set contains M two-letter code
names for the M warehouses of the data sets.  Only capital letters
are used. A single blank separates code names. 

N lines follow the line of code names, containing shipping leg
information in the format: &quot;XX  YY&quot;, with XX and YY being 
the codes for two distinct warehouses in the set that have a 
direct link (a shipping leg) between them. There will be a single 
blank between the warehouse codes.  

The N lines of shipping leg information are followed by P lines of
shipping requests, one request per line.  Each shipping request will
begin with an integer between 1 and 20 inclusive that represents
the size of the shipment.  The shipment size will be followed by a
pair of code names in the format &quot;AA  BB&quot;, with AA and BB
being the code for two distinct warehouses in the set which
represent the source and destination of the requested shipment.

The input will be valid and consistent.  A shipping leg will only be
represented once within a data set.  Data about legs will always
refer to warehouses that have been identified as belonging to the
data set.  See the example below for clarification of the input
format.

Output: The first line of output should read &quot;SHIPPING ROUTES
OUTPUT&quot;. For each data set there should be a section of output
enumerating which data set the output section represents followed
by P lines of the required information. Each of the P lines should
list either the cheapest cost of the respective shipment or the phrase
&quot;NO SHIPMENT POSSIBLE&quot;. The end of the output should be
noted also.  Produce output consistent with the example below.

Example:   The following input data:

2
6  7  5
AA CC QR FF DD AB
AA CC
CC QR
DD CC
AA DD
AA AB
DD QR
AB DD
5  AA AB
14 DD CC
1  CC DD
2  AA FF
13 AB QR
3 0 1
AA BB CC
5  AA CC

should produce the following output:

SHIPPING ROUTES OUTPUT

DATA SET  1

$500
$1400
$100
NO SHIPMENT POSSIBLE
$2600

DATA SET  2

NO SHIPMENT POSSIBLE

END OF OUTPUT</pre>

]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[6  7 5
AA CC QR FF DD AB
AA CC
CC QR
DD CC
AA DD
AA AB
DD QR
AB DD
2 AA AB
2 DD CC
2 CC DD
2 AA QR
2 AA FF
3 0 1
AA BB CC
5 AA CC
2 0 0
AA BF
8 12 2
AA BB CC DD EE FF GG HH
AA BB
DD AA
DD EE
EE FF
FF CC
EE CC
CC DD
AA CC
BB CC
CC GG
BB GG
HH GG
3 HH DD
5 AA CC]]></test_input>
<test_output><![CDATA[SHIPPING ROUTES OUTPUT

DATA SET  1

$200
$200
$200
$400
NO SHIPMENT POSSIBLE

DATA SET  2

NO SHIPMENT POSSIBLE

DATA SET  3

DATA SET  4

$900
$500

END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="C++"><![CDATA[#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <set>
#include <algorithm>
#include <vector>
#include <deque>
#include <queue>
#include <cmath>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <stack>

using namespace std;

//#define fin cin
//#define fout cout
ifstream fin ("test.in");
ofstream fout ("test.out");

int T, ti, M, N, P;
map<string, int> names;
int g[30][30];
const int INF = 100;

int main ()
{
freopen("test.in", "r", stdin);
freopen("test.out", "w", stdout);

fin >> T;
fout << "SHIPPING ROUTES OUTPUT" << endl;
for (ti = 1; ti <= T; ti++) {
   fin >> M >> N >> P;
   names.clear();
   string na;
   for (int i = 0; i < M; i++) {
    fin >> na;
    names[na] = i;
   }
   for (int i = 0; i < M; i++) {
    for (int j = 0; j < M; j++) {
     if (i == j)
      g[i][j] = 0;
     else
      g[i][j] = INF;
    }
   }
   string na2;
   for (int i = 0; i < N; i++) {
    fin >> na >> na2;
    g[names[na]][names[na2]] = 1;
    g[names[na2]][names[na]] = 1;
   }

   for (int k = 0; k < M; k++) {
    for (int i = 0; i < M; i++) {
     for (int j = 0; j < M; j++) {
      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
     }
    }
   }

   fout << endl << "DATA SET " << ti << endl << endl;
   int pri;
   for (int i = 0; i < P; i++) {
    fin >> pri >> na >> na2;
    int dist = g[names[na]][names[na2]];
    if (dist >= INF) {
     fout << "NO SHIPMENT POSSIBLE" << endl;
    } else {
     fout << "$" << dist * pri * 100 << endl;
    }
   }
}

fout << endl << "END OF OUTPUT" << endl;

return 0;
}]]></solution>
<![CDATA[]]>
</item>
<item>
<title><![CDATA[Slurpys]]></title>
<time_limit><![CDATA[1]]></time_limit>
<memory_limit><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<pre style="word-wrap: break-word; white-space: pre-wrap; ">
Problem 8: Slurpys

Recognizing strings based on a set of restrictions is a common
computational problem. 

Problem Statement:  A Slurpy is a string of characters that has certain
properties.  Your program will read in strings of characters and output
whether or not they are Slurpys. 

A Slump is a character string that has the following properties:

1.   Its first character is either a 'D' or an 'E'.
2.   The first character is followed by a string of one or more 'F's.
3.   The string of one or more 'F's is followed by either a Slump or a 'G'.
     The Slump or 'G' that follows the F's ends the Slump.  For example 
     DFFEFFFG is a Slump since it has a 'D' for its first character,
     followed by a string of two F's, and ended by the Slump 'EFFFG'.
4.   Nothing else is a Slump.

A Slimp is a character string that has the following properties:

1.   Its first character is an 'A'.
2.   If it is a two character Slimp then its second 
     and last character is an 'H'.
3.   If it is not a two character Slimp then it is in 
     one of these two forms:
     a. 'A' followed by 'B' followed by a Slimp 
          followed by a 'C'.
     b. 'A' followed by a Slump (see above) 
          followed by a 'C'.
4.   Nothing else is a Slimp.

A Slurpy is a character string that consists of a Slimp followed by a
Slump.

The following diagrams should clarify these definitions:

             [Graphics deleted]


Examples:  

Slumps:        DFG, EFG, DFFFFFG, DFDFDFDFG, DFEFFFFFG
Not Slumps:    DFEFF, EFAHG, DEFG, DG, EFFFFDG
Slimps:        AH, ABAHC, ABABAHCC, ADFGC, ADFFFFGC, ABAEFGCC, ADFDFGC
Not Slimps:    ABC, ABAH, DFGC, ABABAHC, SLIMP, ADGC
Slurpys:       AHDFG, ADFGCDFFFFFG, ABAEFGCCDFEFFFFFG
Not Slurpys:   AHDFGA, DFGAH, ABABCC

Input:   The first line contains an integer N between 1 and 10 describing
how many strings of characters are represented.  The next N lines each
contain a string of 1 to 60 alpha characters.

Output: The first line of output should read SLURPYS OUTPUT.  Each
of the next N lines of output should consist of either YES or NO
depending on whether or not the corresponding input line is a Slurpy.  The
last line of output should read END OF OUTPUT.

Example:   The following input
data:

2
AHDFG
DFGAH

should produce the following
output:

SLURPYS OUTPUT
YES
NO
END OF OUTPUT</pre>
</meta>
</p>
]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
<test_input><![CDATA[13
AHDFG
AEFGCDFDFG
ABABABAHCCCDFG
AHEFEFEFEFEFEFG
AHDFEFG
ABADFGCCEFEFG
ABABAEFEFEFEFGCCCDFEFG
QRST
ABABABCCDFG
ADFGCDFGC
AHDFDFDFGGG
ABCDFG
ABABABCCCDFGG]]></test_input>
<test_output><![CDATA[SLURPYS OUTPUT
YES
YES
YES
YES
YES
YES
YES
NO
NO
NO
NO
NO
NO
END OF OUTPUT]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
<solution language="C++"><![CDATA[#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <set>
#include <algorithm>
#include <vector>
#include <deque>
#include <queue>
#include <cmath>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <stack>

using namespace std;

//#define fin cin
//#define fout cout
ifstream fin ("test.in");
ofstream fout ("test.out");

int n;
string s;
bool isSlump(int start, int end);
bool isSlimp(int start, int end);

bool isSlimp(int start, int end) {
if (end - start < 1)
   return false;

if (s[start] != 'A')
   return false;

if (end - start == 1 && s[end] == 'H')
   return true;

if (s[end] != 'C')
   return false;

if (s[start + 1] == 'B') {
   if (isSlimp(start + 2, end - 1))
    return true;
} else {
   if (isSlump(start + 1, end - 1)) {
    return true;
   }
}

return false;
}

bool isSlump(int start, int end) {
if (end - start < 2)
   return false;

if (s[start] != 'E' && s[start] != 'D') {
   return false;
}

if (s[start + 1] != 'F')
   return false;

int x;
for (x = start + 1; s[x] == 'F'; x++);

if (x == end && s[end] == 'G')
   return true;

if (isSlump(x, end))
   return true;

return false;

}

bool judge() {
for (int i = 1; i < s.size(); i++) {
   if (isSlimp(0, i) && isSlump(i + 1, s.size() - 1))
    return true;
}
return false;
}

int main ()
{
freopen("test.in", "r", stdin);
freopen("test.out", "w", stdout);

cout << "SLURPYS OUTPUT" << endl;
fin >> n;
while (n--) {
   fin >> s;
   if (judge())
    cout << "YES" << endl;
   else
    cout << "NO" << endl;
}

cout << "END OF OUTPUT" << endl;

return 0;
}]]></solution>
<![CDATA[]]>
</item>
</fps>